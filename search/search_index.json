{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Ember","text":"<p>Ember is a lightweight deep learning Python package with C and CUDA implementations, designed for performance and simplicity.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Lightweight: Minimal overhead, focused on core tensor operations.</li> <li>Hardware Accelerated:</li> <li>Pure C implementation for CPU.</li> <li>CUDA implementation for NVIDIA GPUs.</li> <li>NumPy Compatible: Seamless conversion to and from NumPy arrays.</li> <li>Autograd Support: (Upcoming) Automatic differentiation for training neural networks.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import ember\nimport numpy as np\n\n# Create a tensor from a list\nt = ember.Tensor([1.0, 2.0, 3.0])\n\n# Perform operations\nt2 = ember.sin(t)\nprint(t2.to_list())\n# Output: [0.84147096, 0.90929741, 0.14112000] (approx)\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#class-embertensor","title":"Class <code>ember.Tensor</code>","text":"<p>The core data structure of the Ember library. A <code>Tensor</code> represents a multi-dimensional array of elements, similar to NumPy arrays but optimized for Ember's backend (C/CUDA).</p>"},{"location":"api/#constructor","title":"Constructor","text":""},{"location":"api/#__init__data","title":"<code>__init__(data)</code>","text":"<p>Creates a <code>Tensor</code> from a Python list or compatible data structure.</p> <ul> <li>Arguments:</li> <li><code>data</code> (list | number): The data to initialize the tensor with.</li> <li>Returns: A new <code>Tensor</code> instance.</li> </ul> <pre><code>import ember\nt = ember.Tensor([1.0, 2.0, 3.0])\n</code></pre>"},{"location":"api/#from_nparray","title":"<code>from_np(array)</code>","text":"<p>Creates a <code>Tensor</code> from a NumPy array.</p> <ul> <li>Arguments:</li> <li><code>array</code> (numpy.ndarray): The NumPy array to convert.</li> <li>Returns: A new <code>Tensor</code> instance.</li> </ul>"},{"location":"api/#methods","title":"Methods","text":""},{"location":"api/#to_np-numpyndarray","title":"<code>to_np() -&gt; numpy.ndarray</code>","text":"<p>Converts the tensor back to a NumPy array.</p>"},{"location":"api/#to_cpu-list","title":"<code>to_cpu() -&gt; list</code>","text":"<p>Converts the tensor data to a Python list.</p>"},{"location":"api/#reshapenew_shape-tupleint-tensor","title":"<code>reshape(new_shape: tuple[int, ...]) -&gt; Tensor</code>","text":"<p>Returns a <code>Tensor</code> with the same data but a different shape.</p> <ul> <li>Arguments:</li> <li><code>new_shape</code>: The new shape. One dimension can be -1, which will be inferred.</li> </ul>"},{"location":"api/#operators","title":"Operators","text":"<p><code>Tensor</code> objects support standard Python operators.</p> Operator Method Description Formula <code>+</code> <code>__add__</code> Elementwise addition \\(c_i = a_i + b_i\\) <code>-</code> <code>__sub__</code> Elementwise subtraction \\(c_i = a_i - b_i\\) <code>*</code> <code>__mul__</code> Elementwise multiplication \\(c_i = a_i \\cdot b_i\\) <code>/</code> <code>__truediv__</code> Elementwise division \\(c_i = \\frac{a_i}{b_i}\\) <code>@</code> <code>__matmul__</code> Matrix multiplication \\(C_{ij} = \\sum_k A_{ik} B_{kj}\\) <code>-</code> <code>__neg__</code> Elementwise negation \\(b_i = -a_i\\) <code>&gt;</code> <code>__gt__</code> Elementwise greater than \\(c_i = 1 \\text{ if } a_i &gt; b_i \\text{ else } 0\\)"},{"location":"api/#functional-api","title":"Functional API","text":"<p>All functional operations are available directly under the <code>ember</code> namespace.</p>"},{"location":"api/#elementwise-math-operations","title":"Elementwise Math Operations","text":"<p>Functions that operate on each element of the input tensor independently. For an input tensor \\(A\\) with elements \\(a_i\\), the output tensor \\(B\\) has elements \\(b_i\\):</p> \\[b_i = f(a_i)\\]"},{"location":"api/#trigonometric","title":"Trigonometric","text":"Function Description Equation <code>ember.sin(x)</code> Sine \\(b_i = \\sin(a_i)\\) <code>ember.cos(x)</code> Cosine \\(b_i = \\cos(a_i)\\) <code>ember.tan(x)</code> Tangent \\(b_i = \\tan(a_i)\\) <code>ember.ctg(x)</code> Cotangent \\(b_i = \\cot(a_i)\\)"},{"location":"api/#hyperbolic","title":"Hyperbolic","text":"Function Description Equation <code>ember.sinh(x)</code> Hyperbolic Sine \\(b_i = \\sinh(a_i)\\) <code>ember.cosh(x)</code> Hyperbolic Cosine \\(b_i = \\cosh(a_i)\\) <code>ember.tanh(x)</code> Hyperbolic Tangent \\(b_i = \\tanh(a_i)\\) <code>ember.ctgh(x)</code> Hyperbolic Cotangent \\(b_i = \\coth(a_i)\\)"},{"location":"api/#other","title":"Other","text":"Function Description Equation <code>ember.exp(x)</code> Exponential \\(b_i = e^{a_i}\\)"},{"location":"api/#binary-elementwise-operations","title":"Binary Elementwise Operations","text":"<p>Functions that extend elementwise operations to two tensors (or a tensor and a scalar). For inputs \\(A, B\\), the output \\(C\\) is:</p> \\[c_i = f(a_i, b_i)\\] Function Description Equation <code>ember.max(a, b)</code> Elementwise maximum \\(c_i = \\max(a_i, b_i)\\) <code>ember.min(a, b)</code> Elementwise minimum \\(c_i = \\min(a_i, b_i)\\)"},{"location":"api/#random-module-emberrandom","title":"Random Module (<code>ember.random</code>)","text":"<p>Utilities for generating tensors with random or constant values.</p>"},{"location":"api/#emberrandomuniformlow-high-size","title":"<code>ember.random.uniform(low, high, size)</code>","text":"<p>Draws samples from a uniform distribution.</p> <ul> <li>Arguments:</li> <li><code>low</code> (float): Lower boundary of the output interval.</li> <li><code>high</code> (float): Upper boundary of the output interval.</li> <li><code>size</code> (tuple[int]): Shape of the output tensor.</li> <li>Equation: \\(x_i \\sim U(\\text{low}, \\text{high})\\)</li> </ul>"},{"location":"api/#emberrandomconstantvalue-size","title":"<code>ember.random.constant(value, size)</code>","text":"<p>Return a new tensor of given shape and type, filled with <code>value</code>.</p> <ul> <li>Arguments:</li> <li><code>value</code> (float): Fill value.</li> <li><code>size</code> (tuple[int]): Shape of the output tensor.</li> <li>Equation: \\(x_i = \\text{value}\\)</li> </ul>"},{"location":"api/#emberrandomzerossize","title":"<code>ember.random.zeros(size)</code>","text":"<p>Returns a new tensor of given shape, filled with zeros.</p>"},{"location":"api/#emberrandomonessize","title":"<code>ember.random.ones(size)</code>","text":"<p>Returns a new tensor of given shape, filled with ones.</p>"},{"location":"api/#neural-networks-embernn","title":"Neural Networks (<code>ember.nn</code>)","text":"<p>Components for building neural networks. Note: You may need to import submodules explicitly, e.g., <code>from ember.nn.layers import Linear</code>.</p>"},{"location":"api/#layers","title":"Layers","text":""},{"location":"api/#embernnlayerslinearin_features-out_features","title":"<code>ember.nn.layers.Linear(in_features, out_features)</code>","text":"<p>Applies a linear transformation to the incoming data.</p> <ul> <li>Arguments:</li> <li><code>in_features</code> (int): Size of each input sample.</li> <li><code>out_features</code> (int): Size of each output sample.</li> <li>Forward: \\(y = x W + b\\)</li> <li>Where \\(W\\) is weight matrix of shape <code>(in_features, out_features)</code> and \\(b\\) is bias of shape <code>(out_features,)</code>.</li> </ul> <p>Methods:</p> <ul> <li><code>reset()</code>: Re-initializes weights and biases.</li> <li><code>parameters() -&gt; list[Tensor]</code>: Returns <code>[w, b]</code>.</li> <li><code>gradients() -&gt; list[Tensor | None]</code>: Returns <code>[grad_w, grad_b]</code>.</li> </ul>"},{"location":"api/#activations","title":"Activations","text":"<p>Activation functions applied elementwise.</p>"},{"location":"api/#embernnactivationsrelu","title":"<code>ember.nn.activations.ReLU</code>","text":"<p>Rectified Linear Unit.</p> <ul> <li>Equation: \\(f(x) = \\max(0, x)\\)</li> </ul>"},{"location":"api/#embernnactivationssigmoid","title":"<code>ember.nn.activations.Sigmoid</code>","text":"<p>Sigmoid function.</p> <ul> <li>Equation: \\(f(x) = \\frac{1}{1 + e^{-x}}\\)</li> </ul>"},{"location":"api/#embernnactivationstanh","title":"<code>ember.nn.activations.Tanh</code>","text":"<p>Hyperbolic Tangent function.</p> <ul> <li>Equation: \\(f(x) = \\tanh(x)\\)</li> </ul>"},{"location":"api/#embernnactivationsgelu","title":"<code>ember.nn.activations.GELU</code>","text":"<p>Gaussian Error Linear Unit (using <code>tanh</code> approximation).</p> <ul> <li>Equation: \\(f(x) \\approx 0.5 x (1 + \\tanh(0.8 x))\\)</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Ember requires Python 3.11 or later. You can install it from source.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>CMake (&gt;= 3.18)</li> <li>C Compiler (GCC, Clang, or MSVC)</li> <li>CUDA Toolkit (Optional, for GPU support)</li> </ul>"},{"location":"installation/#installing-from-source","title":"Installing from Source","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/pawel002/ember\ncd ember\n</code></pre> <ol> <li>Create a virtual environment (recommended) and download dependencies:</li> </ol> <pre><code>uv sync\nsource .venv/bin/activate\n</code></pre> <ol> <li>Install the package:</li> </ol> <pre><code>uv pip install -e .\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Ember provides a <code>Tensor</code> class and various mathematical operations.</p>"},{"location":"usage/#creating-tensors","title":"Creating Tensors","text":"<p>You can create tensors from Python lists or NumPy arrays.</p> <pre><code>import ember as em\nimport numpy as np\n\nfrom ember import Tensor\n\n# From list\na = Tensor([1, 2, 3])\n\n# From NumPy\nnp_arr = np.array([1.0, 2.0, 3.0], dtype=np.float32)\nb = Tensor(np_arr) # Automatically converts from buffer\n</code></pre>"},{"location":"usage/#operations","title":"Operations","text":"<p>Ember supports element-wise operations and broadcasting with scalars.</p>"},{"location":"usage/#arithmetic","title":"Arithmetic","text":"<pre><code>c = a + b\nd = a * 2.0\ne = em.max(a, b)\n</code></pre>"},{"location":"usage/#trigonometric-hyperbolic","title":"Trigonometric &amp; Hyperbolic","text":"<pre><code># Standard trig\ns = em.sin(a)\nc = em.cos(a)\n\n# Hyperbolic\nsh = em.sinh(a)\nth = em.tanh(a)\n</code></pre>"},{"location":"usage/#matrix-multiplication","title":"Matrix Multiplication","text":"<pre><code># Create 2x2 matrices (flattened logic for now, or reshape support pending)\n# Note: Current implementation is basic.\npass\n</code></pre>"},{"location":"usage/#data-exchange","title":"Data Exchange","text":"<p>Convert back to standard Python/NumPy types easily.</p> <pre><code># To List\ndata_list = c.to_list()\n\n# To NumPy\ndata_np = c.to_np()\n</code></pre>"}]}